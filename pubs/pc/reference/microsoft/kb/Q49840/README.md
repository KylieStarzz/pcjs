---
layout: page
title: "Q49840: Use of the /Gt Switch in C"
permalink: /pubs/pc/reference/microsoft/kb/Q49840/
---

## Q49840: Use of the /Gt Switch in C

	Article: Q49840
	Version(s): 5.10   | 5.10
	Operating System: MS-DOS | OS/2
	Flags: ENDUSER |
	Last Modified: 7-DEC-1989
	
	Question:
	
	I am using large memory model and the /Gt switch when programming and
	I still get the message "stack plus data larger than 64K." Could you
	give me some pointers about where data goes when using large model? Do
	heap and stack still remain in DGROUP when I use /Gt?
	
	Response:
	
	What goes out of the default data segment depends on how you use /Gt.
	/Gt alone is the same as /Gt256, which means that ONLY data items of
	size 256 and greater get moved out. If you have a lot of data items
	smaller than that, that data will NOT get moved out. With /Gt256, it
	is still possible that the data left in DGROUP plus the stack could
	exceed 64K.
	
	As the value on the /Gt switch becomes smaller, more and more data
	gets pushed out. /Gt0 pushes all of the data generated by your program
	out. However, it also generates some constants in the logical segment
	_CONST in DGROUP, 2 bytes for each extern or uninitialized variable
	moved. The following classes of variables will generate a 2-byte
	segment address in DGROUP for EACH variable of that class declared
	when /Gt0 is used:
	
	1. All extern declarations, such as "extern int i;"
	
	2. All declarations without storage class that are not initialized,
	   such as "int i;"
	
	Initialized variables such as "int i = 0;", provided that the sum of
	their sizes is less then 64K, are treated as a group and generate only
	one segment address in DGROUP per module. Therefore, the optimal
	number for minimizing DGROUP space is /Gt3. /Gt3 is better than /Gt0
	for uninitialized and extern variables because /Gt0 will move out 1-
	and 2-byte data elements to the far heap, replacing them with 2-byte
	segment addresses. Not only does this NOT save you space in DGROUP
	V.S. /Gt3, but it will increase the overall size of the executable
	V.S. /Gt3 as you also have to pay 2 bytes in the far heap per data
	element moved. Another reason to use /Gt3 over /Gt0 is that although
	the size of DGROUP will remain the same, /Gt0 will cause character and
	integer data elements to be addressed with far pointers, slowing
	execution. With /Gt0, all that remains in DGROUP is the stack, several
	kilobytes of variables associated with the run-time library, the near
	heap (from which will be allocated some file buffers and the local
	copy of the environment), and the 2-byte segment addresses for data
	items moved out as needed.
