---
layout: page
title: "Q67786: Code Generation Error with C 6.00 and Global Variables"
permalink: /pubs/pc/reference/microsoft/kb/Q67786/
---

	Article: Q67786
	Product: Microsoft C
	Version(s): 6.00 6.00a | 6.00 6.00a
	Operating System: MS-DOS     | OS/2
	Flags: ENDUSER | buglist6.00 buglist6.00a
	Last Modified: 6-FEB-1991
	
	The sample program below does not compile properly when using any
	optimizations other than /Od under C versions 6.00 and 6.00a. The code
	generated by the compiler incorrectly assumes that foo and bar are
	equal after the call to the function inc_foo. The compiler then
	accesses bar[1] by using the value of foo rather than the value of
	bar. This generates the wrong effect on the array being modified.
	
	There are several workarounds:
	
	1. Use the /Od option or the /qc option.
	
	2. Declare foo as a volatile pointer to a char.
	
	3. Change the code to assign buf to bar first.
	
	Microsoft has confirmed this to be a problem in C versions 6.00 and
	6.00a. We are researching this problem and will post new information
	here as it becomes available.
	
	Sample Code
	-----------
	
	#include <stdio.h>
	char inc_foo (void);
	
	char * foo;
	char * bar;
	char * buf = "....................";
	
	main ()
	{
	   foo= buf;
	   bar= buf;
	   bar[1]= inc_foo ();
	   printf ("buf = %s\n", buf);
	   printf ("foo = %d\nbar = %d\n", foo, bar);
	}
	
	char inc_foo ()
	{
	   foo += 10;
	   return (char) '[';
	}
	
	The correct output is:
	
	buf = .[..................
	foo = 76
	bar = 66
	
	The output generated is:
	
	buf = ...........[........
	foo = 76
	bar = 66
